# Web Project Starter with Claude Code + Deno 2

You must have Claude Code to effectively use this template!! 

[Claude Pricing and plans](https://www.claude.com/pricing)

## ‚ö° Opinionated & Production-Ready

**This is an opinionated starter template** with a pre-selected tech stack designed to work together seamlessly. The architecture is chosen for you so you can focus on building features, not debating technology choices.

### The Stack (Fixed)

- **Runtime:** Deno 2
- **Backend:** Hono (REST API)
- **Frontend:** Fresh + Preact (optional, can be removed)
- **Database:** Deno KV
- **Deployment:** Deno Deploy (edge)
- **Testing:** Deno's built-in test runner

**‚úÖ Use this template if you want this exact stack.**
**‚ùå If you need Node.js, Express, React, PostgreSQL, etc. - this template won't help.**

### Goals

* Go from idea to deployed project quickly (< 1 hour)
* Leverage Claude Code AI agents for mockups, feature development, and testing
* Opinionated stack reduces tokens and decision fatigue
* Test-Driven Development (TDD) and End to End (e2e) tests prevents regressions
* Production-ready from day one and ready for [Deno Deploy](https://deno.com/deploy)

## Quick Start

### 1. Install Deno 2

```bash
# macOS/Linux
curl -fsSL https://deno.land/install.sh | sh

# Windows (PowerShell)
irm https://deno.land/install.ps1 | iex

# Or use package managers
# macOS: brew install deno
# Windows: choco install deno
# Linux: snap install deno
```

### 2. Use This Template

Click "Use this template" on GitHub to create a new repository with the template.

Then clone your new repository that was created. 

```bash
git clone <your-repo-url>
cd <your-project>
```

### 3. Run the project

```bash
# Start the minimal server to see it running
deno task dev
# Backend: http://localhost:8000
# Frontend: http://localhost:3000
```

**Note**: The template includes a minimal backend (health check) and frontend starter which shows links the component gallery and mockups which can be generated by the mockup agent. Features will be created leveraging the commands below.


### 4. Build Your First Feature

The architecture is pre-defined (see `docs/architecture.md`). You just need to build features.

Choose your workflow:

#### Option A: Quick Start (Recommended - 90% of users)


```bash
# Create a mockup and describe what you want to implement
claude mockup 
```

```bash
# from within Claude Code use the /new-feature command
# Provide the mockup to implement and provide more details on the functionality
/new-feature
```

**WARNING**: There is the option `claude --dangerously-skip-permissions` to skip being prompted for running commands and changing files. THIS IS DANGEROUS as your system can be accessed. If you proceed with this command, it is recommended to execute it in a sandboxed environment.

**Why this works:** `/new-feature` handles everything you need:
- First run: Asks about your project vision
- Creates feature-specific documentation
- 40-50% more token efficient than global docs
- Best for incremental development

#### Option B: Detailed Planning (Large/complex projects)

```bash
# Step 1: Document comprehensive project vision
/requirements

# Step 2: Review or customize architecture (optional)
/architect

# Step 3: Create Mockups
/mockup

# Step 4: Build your first feature with tests
/new-feature
```

**When to use this:**
- Planning 10+ features upfront
- Need detailed stakeholder documentation
- Multiple user personas to consider
- Complex integration requirements

**The /architect agent is also valuable for:**
- Migrating from Deno KV to PostgreSQL if the project outgrows KV
- Splitting into microservices when scaling
- Adding new infrastructure (Redis, message queues, etc.)
- Major refactoring decisions (authentication changes, API versioning)
- Creating ADRs for significant changes


## Architecture

### Development Workflow

```
Requirements ‚Üí Architecture ‚Üí API Design ‚Üí Tests ‚Üí Implementation ‚Üí Review
     ‚Üì             ‚Üì              ‚Üì          ‚Üì           ‚Üì            ‚Üì
  (agent)      (agent)        (agent)   (agent)     (agents)      (command)
```

### Sub-Agents

Each agent is a specialized Claude Code agent with a specific purpose:

| Agent | Purpose | Input | Output |
|-------|---------|-------|--------|
| **requirements-agent** | Gather and document requirements | User conversation | `docs/requirements.md` |
| **architect-agent** | **Update** system architecture | Current `architecture.md` | Updated `docs/architecture.md`, `docs/adr/*.md` |
| **api-designer-agent** | Design API contracts | `requirements.md`, `architecture.md` | `docs/api-spec.md`, `docs/data-models.md` |
| **test-writer-agent** | Write tests (TDD Red phase) | `api-spec.md` | `tests/**/*.test.ts` |
| **backend-agent** | Implement backend (TDD Green) | `api-spec.md`, tests | Backend code |
| **frontend-agent** | Implement frontend (TDD Green) | `api-spec.md`, tests | Frontend components |
| **orchestrator-agent** ‚ö° | Intelligent workflow automation (Advanced) | Project state | Automated execution |

**Note:** Architecture ships pre-defined. Most users won't need requirements-agent or architect-agent.

### Slash Commands

Quick workflows for common tasks:

| Command | Level | Description | When to Use |
|---------|-------|-------------|-------------|
| `/requirements` | Optional | Gather project-wide requirements | Large projects (10+ features) or stakeholder docs |
| `/architect` | Optional | **Update** architecture | Major changes only (DB migration, microservices) |
| `/mockup` | **Visual** | Create UI mockup | Quick visual prototyping before building |
| `/design-api` | Manual | Design API contracts | Before implementation |
| `/write-tests` | Manual | Write tests (TDD) | Before coding (Red phase) |
| `/implement-backend` | Manual | Implement backend | After tests are written |
| `/implement-frontend` | Manual | Implement UI | After backend is ready |
| `/new-feature` | **Recommended** | Full feature workflow (semi-automated) | Adding a complete new feature |
| `/auto-feature` ‚ö° | Advanced | Intelligent orchestration (fully automated) | Complex projects, max automation |
| `/review` | Utility | Code review checklist | Before merging or deploying |

## Automation Levels

This template provides **3 levels of automation** to match your needs:

### üîß Level 1: Manual (Full Control)

Run each agent individually for maximum control and learning.

```bash
/requirements ‚Üí /architect ‚Üí /design-api ‚Üí /write-tests ‚Üí /implement-backend ‚Üí /implement-frontend
```

**Best for:** Learning, small projects, experimentation, custom workflows

**Token usage:** ~20K per feature | **Time:** ~15 min | **Control:** ‚≠ê‚≠ê‚≠ê

---

### ‚öôÔ∏è Level 2: Command Orchestration (Recommended)

Semi-automated workflow with guided steps and user approval.

```bash
/new-feature
> "Add user authentication"
```

**Best for:** Most projects (80% of use cases), production work, teams

**Token usage:** ~25K per feature | **Time:** ~10 min | **Control:** ‚≠ê‚≠ê

---

### ‚ö° Level 3: Intelligent Orchestration (Advanced)

Fully automated with smart decisions, validation, and error recovery.

```bash
/auto-feature
> "Add user authentication"
```

**Best for:** Complex projects, many similar features, maximum automation

**Token usage:** ~35K per feature | **Time:** ~5 min | **Control:** ‚≠ê

**See [Orchestration Guide](docs/guides/ORCHESTRATION_GUIDE.md) for detailed comparison.**

---

## How to Use

### Starting a New Project

**Recommended for most users:**

```bash
# Just start building - the command handles everything
/new-feature
```

On first run, `/new-feature` will:
1. Detect this is your first feature
2. Ask about your project vision (lightweight)
3. Use the pre-defined architecture (Hono + Fresh + Deno KV)
4. Guide you through feature development

**For large/complex projects requiring detailed planning:**

1. **Document Comprehensive Requirements** (Optional)
   ```bash
   /requirements
   ```
   Use this when you need:
   - Detailed stakeholder documentation
   - Planning 10+ features upfront
   - Multiple user personas to consider
   - Complex integration requirements

2. **Review Architecture** (Optional)
   Architecture is pre-defined in `docs/architecture.md`. Use `/architect` only if you need changes.

3. **Build Features**
   ```bash
   /new-feature
   ```
   Then use `/new-feature` for each feature you build.

### Adding Features (Day-to-Day Development)

**Option 1: Complete Feature Workflow** (Recommended)

```bash
/new-feature
```

This handles everything: requirements ‚Üí API design ‚Üí tests ‚Üí backend ‚Üí frontend

**Option 2: Visual-First Approach** (For UI-heavy features)

```bash
# 1. Create mockup first (fast visual prototype)
/mockup
> Describe the UI you want to see
> Visit http://localhost:3000/mockups/[name] to review

# 2. Convert to full feature (auto-detects mockup)
/new-feature
> Agent: "I found /mockups/[name]. Convert it? (y/n)"
> You: "yes"
> Agent builds full feature with backend, tests, real data
> Agent: "Delete mockup? (y/n)" - automatic cleanup
```

**Why this works:**
- Mockup context embedded in TSX file (no separate spec files)
- `/new-feature` auto-detects and reads mockup metadata
- Automatic cleanup after conversion
- 47% fewer tokens than old mockup workflow

**Option 3: Manual Control** (Advanced)

Run each step individually for maximum control:

```bash
/design-api       # Design API endpoints
/write-tests      # Write tests (TDD Red phase)
/implement-backend # Implement backend (TDD Green phase)
/implement-frontend # Build UI components
/review           # Code review
```

### Understanding Feature-Scoped Workflow

Features are now organized in a dedicated folder structure:
```
features/
‚îú‚îÄ‚îÄ proposed/           # Features being developed
‚îÇ   ‚îî‚îÄ‚îÄ user-auth/
‚îÇ       ‚îú‚îÄ‚îÄ requirements.md
‚îÇ       ‚îú‚îÄ‚îÄ api-spec.md
‚îÇ       ‚îî‚îÄ‚îÄ data-models.md
‚îî‚îÄ‚îÄ implemented/        # Completed features
    ‚îî‚îÄ‚îÄ user-profile/
        ‚îú‚îÄ‚îÄ requirements.md
        ‚îú‚îÄ‚îÄ api-spec.md
        ‚îú‚îÄ‚îÄ data-models.md
        ‚îî‚îÄ‚îÄ implementation.md
```

Benefits:
- **40-50% token reduction** per feature
- **Better organization** - each feature self-contained
- **Easy rollback** - delete feature folder to remove
- **Preserved history** - all features documented in implemented/

See `features/README.md` for detailed documentation.

## Test-Driven Development (TDD)

This template enforces TDD workflow:

1. **Red**: Write failing tests first (`/write-tests`)
2. **Green**: Write minimal code to pass (`/implement-backend` or `/implement-frontend`)
3. **Refactor**: Improve code while keeping tests green

### Running Tests

```bash
# Run all tests
deno test

# Run with coverage
deno task test:coverage
deno task coverage

# Watch mode
deno task test:watch

# Specific file
deno test tests/users_test.ts
```

## Project Structure

```
.
‚îú‚îÄ‚îÄ .claude/
‚îÇ   ‚îú‚îÄ‚îÄ agents/              # Sub-agent definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ requirements-agent.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ requirements-agent-feature.md  # ‚≠ê Feature-scoped (lightweight)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ architect-agent.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-designer-agent.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api-designer-agent-feature.md  # ‚≠ê Feature-scoped (lightweight)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ test-writer-agent.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ backend-agent.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ frontend-agent.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ orchestrator-agent.md     # Advanced: Intelligent orchestration
‚îÇ   ‚îî‚îÄ‚îÄ commands/            # Slash command definitions
‚îÇ       ‚îú‚îÄ‚îÄ new-feature.md            # ‚≠ê Recommended workflow (uses feature-scoped agents)
‚îÇ       ‚îú‚îÄ‚îÄ feature-complete.md       # ‚≠ê Finalize and move to implemented
‚îÇ       ‚îú‚îÄ‚îÄ mockup.md                 # Create UI mockups/prototypes
‚îÇ       ‚îú‚îÄ‚îÄ design.md                 # Update design system and styling
‚îÇ       ‚îú‚îÄ‚îÄ auto-feature.md           # Advanced: Full automation
‚îÇ       ‚îú‚îÄ‚îÄ requirements.md
‚îÇ       ‚îú‚îÄ‚îÄ architect.md
‚îÇ       ‚îú‚îÄ‚îÄ design-api.md
‚îÇ       ‚îú‚îÄ‚îÄ write-tests.md
‚îÇ       ‚îú‚îÄ‚îÄ implement-backend.md
‚îÇ       ‚îú‚îÄ‚îÄ implement-frontend.md
‚îÇ       ‚îî‚îÄ‚îÄ review.md
‚îú‚îÄ‚îÄ features/                # ‚≠ê Feature-scoped documentation (NEW)
‚îÇ   ‚îú‚îÄ‚îÄ README.md           # Guide to feature-scoped workflow
‚îÇ   ‚îú‚îÄ‚îÄ _templates/         # Templates for feature docs
‚îÇ   ‚îú‚îÄ‚îÄ proposed/           # Features being developed
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ {feature-name}/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ requirements.md
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ api-spec.md
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ data-models.md
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ notes.md
‚îÇ   ‚îî‚îÄ‚îÄ implemented/        # Completed features
‚îÇ       ‚îî‚îÄ‚îÄ {feature-name}/
‚îÇ           ‚îú‚îÄ‚îÄ requirements.md
‚îÇ           ‚îú‚îÄ‚îÄ api-spec.md
‚îÇ           ‚îú‚îÄ‚îÄ data-models.md
‚îÇ           ‚îî‚îÄ‚îÄ implementation.md
‚îú‚îÄ‚îÄ docs/                    # Project-wide documentation
‚îÇ   ‚îú‚îÄ‚îÄ requirements.md      # Overall project requirements
‚îÇ   ‚îú‚îÄ‚îÄ architecture.md      # System architecture
‚îÇ   ‚îú‚îÄ‚îÄ api-spec.md         # Global API specification (optional)
‚îÇ   ‚îú‚îÄ‚îÄ data-models.md      # Shared data models (optional)
‚îÇ   ‚îú‚îÄ‚îÄ adr/                # Architecture Decision Records
‚îÇ   ‚îî‚îÄ‚îÄ guides/                 # Detailed guides (see docs/QUICK_REFERENCE.md)
‚îú‚îÄ‚îÄ backend/                 # Backend source code
‚îÇ   ‚îú‚îÄ‚îÄ main.ts             # Backend entry point (Hono server)
‚îÇ   ‚îú‚îÄ‚îÄ routes/             # API routes
‚îÇ   ‚îú‚îÄ‚îÄ lib/                # Utilities and API client
‚îÇ   ‚îî‚îÄ‚îÄ types/              # TypeScript types
‚îú‚îÄ‚îÄ frontend/                # Frontend Fresh 2 application
‚îÇ   ‚îú‚îÄ‚îÄ routes/             # Fresh file-based routes
‚îÇ   ‚îú‚îÄ‚îÄ islands/            # Interactive client components
‚îÇ   ‚îú‚îÄ‚îÄ components/         # Shared UI components
‚îÇ   ‚îî‚îÄ‚îÄ static/             # Static assets
‚îî‚îÄ‚îÄ tests/                   # Test files
    ‚îú‚îÄ‚îÄ unit/               # Unit tests
    ‚îú‚îÄ‚îÄ integration/        # Integration tests
    ‚îî‚îÄ‚îÄ helpers/            # Test utilities
```

## Available Commands

### Development
```bash
deno task dev              # Start both backend + frontend
deno task dev:backend      # Backend only (port 8000)
deno task dev:frontend     # Frontend only (port 3000)
```

### Production & Deployment
```bash
deno task build            # Build both backend + frontend (for Docker/VPS)
deno task build:backend    # Compile backend to executable
deno task build:frontend   # Build frontend for production
deno task preview          # Preview production backend build

# Deno Deploy (Recommended)
deno task deploy           # Deploy to Deno Deploy (production)
deno task deploy:preview   # Deploy preview environment
```

**Note:** Development-only routes (`/design-system`, `/mockups`) are automatically excluded from production builds. See [Production Deployment Guide](docs/PRODUCTION_DEPLOYMENT.md) for details.

### Testing
```bash
deno task test             # Run all tests
deno task test:watch       # Run tests in watch mode
deno task test:coverage    # Generate test coverage report
deno task coverage         # Generate LCOV coverage report
```

### Code Quality
```bash
deno task check            # Run lint + format check + type check
deno task lint             # Run linter
deno task lint:fix         # Fix linting issues automatically
deno task fmt              # Format code
deno task fmt:check        # Check code formatting
deno task type-check       # Type check all TypeScript files
```

### Utilities
```bash
deno task clean            # Remove build artifacts and cache
deno task kill-ports       # Kill processes on ports 3000 and 8000
```

**Note:** Use `kill-ports` if you get "port already in use" errors from hidden instances of the app.

### Deno KV Management
```bash
deno task kv:seed          # Populate local KV database with sample data
deno task kv:reset         # Delete local KV database (fresh start)
deno task kv:inspect       # List all entries in local KV database

# With options
deno task kv:inspect -- --prefix=users  # Show only 'users' keys
deno task kv:inspect -- --limit=10      # Limit to 10 entries
```

## Token Efficiency

This template is designed to be token-efficient with **multiple optimization layers**:

### API Design Optimizations (NEW ‚≠ê)
1. **Feature-scoped documentation**: Features documented separately, reducing context by 40-50%
2. **Pattern reference system** ‚≠ê: Reusable API patterns and error responses (saves ~500-800 tokens/feature)
3. **Shorthand templates** ‚≠ê: Condensed format for simple CRUD features (saves ~400-600 tokens/feature)
4. **Smart agent instructions** ‚≠ê: Agents automatically choose optimal templates and reference patterns

**See [Token Optimization Guide](docs/guides/TOKEN_OPTIMIZATION_GUIDE.md) for API design details.**

### Test Writing Optimizations (NEW ‚≠ê)
5. **CRUD test templates** ‚≠ê: Pre-built test suite for simple services (saves ~400-600 tokens/service)
6. **Test data patterns** ‚≠ê: Reusable test data builders (saves ~100-150 tokens/file)
7. **Test pattern references** ‚≠ê: Common testing scenarios (saves ~200-400 tokens/service)

**See [Test Optimization Guide](docs/guides/TEST_OPTIMIZATION_GUIDE.md) for test writing details.**

### Backend Implementation Optimizations (NEW ‚≠ê)
8. **CRUD service templates** ‚≠ê: Complete service implementation (saves ~600-800 tokens/service)
9. **CRUD route templates** ‚≠ê: Standard REST endpoints (saves ~400-600 tokens/service)
10. **Backend pattern references** ‚≠ê: Common backend patterns (saves ~200-400 tokens/service)

**See [Backend Optimization Guide](docs/guides/BACKEND_OPTIMIZATION_GUIDE.md) for implementation details.**

### Frontend Implementation Optimizations (NEW ‚≠ê)
11. **Fresh route templates** ‚≠ê: Pre-built list/detail pages (saves ~500-700 tokens/page)
12. **Design system components** ‚≠ê: Button, Card, Input, Modal, etc. (saves ~300-500 tokens/feature)
13. **Frontend pattern references** ‚≠ê: Form islands, API clients, state management (saves ~400-600 tokens/feature)

**See [Frontend Optimization Guide](docs/guides/FRONTEND_OPTIMIZATION_GUIDE.md) for UI implementation details.**

### General Best Practices
14. **Agents read files, not chat history**: Each agent reads output files from previous agents
15. **Narrow agent scope**: Each agent has a specific, limited responsibility
16. **Structured outputs**: Agents produce markdown files with clear structure
17. **No redundancy**: Information is stored once in files, not repeated in context

### Token Usage Comparison

| Phase | Old Approach | New (Optimized) | Savings |
|-------|--------------|-----------------|---------|
| **API Design** | ~25,000 tokens | ~8-12,000 tokens | **52-68%** |
| **Test Writing** | ~7,500 tokens | ~3,600 tokens | **52%** |
| **Backend Implementation** | ~2,500 tokens | ~1,000 tokens | **60%** |
| **Frontend Implementation** | ~3,000 tokens | ~1,200 tokens | **60%** |
| **Total per feature** | **~38,000 tokens** | **~13,800-17,800 tokens** | **53-64%** |

### Workflow Comparison

| Approach | Tokens/Feature | Speed | Best For |
|----------|----------------|-------|----------|
| **Pattern-optimized** ‚≠ê | **~11-15K** | **Fast** | **New features (recommended)** |
| Feature-scoped only | ~15-20K | Fast | Basic features |
| Manual (Level 1) | ~20K | Slower | Learning, small projects |
| Commands (Level 2) | ~25K | Fast | Initial project setup |
| Orchestration (Level 3) | ~35K | Fastest | Complex projects |

**NEW: Fully Optimized Workflow**: Use `/new-feature`, `/write-tests`, `/implement-backend`, and `/implement-frontend` to automatically apply all 13 optimization layers:
- Feature-scoped documentation (40-50% savings on API design)
- API pattern references (15-20% additional savings)
- Shorthand API templates (10-15% additional savings)
- CRUD test templates (50% savings on tests)
- Test data patterns (additional test savings)
- CRUD service templates (50-60% savings on backend)
- CRUD route templates (additional backend savings)
- Fresh route templates (55-65% savings on frontend pages)
- Design system components (additional frontend savings)
- **Total: 53-64% reduction in full feature development (API + Tests + Backend + Frontend)**

## Best Practices

### Architecture Principles

- **Start Simple**: Don't over-engineer for future requirements
- **Boring Technology**: Use mature, well-documented tools
- **Clear Separation**: Routes ‚Üí Controllers ‚Üí Services ‚Üí Models
- **Avoid Complexity**: No microservices for small projects

### Code Principles

- **YAGNI**: You Ain't Gonna Need It
- **KISS**: Keep It Simple, Stupid
- **DRY**: Don't Repeat Yourself
- **SOLID**: Single Responsibility, Open/Closed, etc.

### Testing Principles

- **Test First**: Write tests before implementation (TDD)
- **AAA Pattern**: Arrange, Act, Assert
- **One Assertion**: Focus each test on one thing
- **Cover Edge Cases**: Test errors, nulls, boundaries

## Technology Stack

This template is built on **Deno 2** with modern, production-ready tools optimized for **serverless edge deployment**.

### Backend (Deno 2)
- **Runtime**: Deno 2.0+ (secure, TypeScript-first)
- **Framework**: Hono (ultra-fast, edge-ready, works on Deno Deploy)
- **Language**: TypeScript (built-in, no build step)
- **Database**: **Deno KV (recommended)** - zero-config, distributed, edge-ready
  - PostgreSQL available when complex queries needed
- **Testing**: Deno's built-in test runner with in-memory KV
- **Validation**: Zod
- **Deployment**: **Deno Deploy (recommended)** - zero-config serverless

### Frontend (Fresh + Preact)
- **Framework**: Fresh 1.7+ (Deno-native, SSR, Islands architecture)
- **UI Library**: Preact (lightweight React alternative)
- **State**: Preact Signals (reactive state management)
- **Styling**: Tailwind CSS (built-in with Fresh)
- **Deployment**: Works seamlessly on Deno Deploy

### Database: Deno KV (Default)

**Why Deno KV is the recommended default:**

‚úÖ **Zero Configuration** - No setup, connection strings, or migrations needed
‚úÖ **Built-in** - Ships with Deno runtime, no external database required
‚úÖ **Edge-Ready** - Globally distributed on Deno Deploy
‚úÖ **ACID Transactions** - Atomic operations for data consistency
‚úÖ **Fast** - Optimized for key-value and simple queries
‚úÖ **Easy Testing** - In-memory mode (`:memory:`) for isolated tests
‚úÖ **Serverless-Native** - Perfect for edge deployment

**When to use PostgreSQL instead:**
- Need complex multi-table JOINs
- Require advanced aggregations (GROUP BY with HAVING)
- Full-text search at database level
- Existing PostgreSQL infrastructure
- Complex reporting and analytics

### Deployment: Deno Deploy (Default)

**Why Deno Deploy is the recommended deployment target:**

‚úÖ **Zero Configuration** - No Docker, no infrastructure, just deploy
‚úÖ **Global Edge Network** - Low latency worldwide (35+ regions)
‚úÖ **Built-in Deno KV** - Distributed key-value store at the edge
‚úÖ **Auto-Scaling** - Serverless, scales automatically
‚úÖ **GitHub Integration** - Deploy on push with GitHub Actions
‚úÖ **Free Tier** - Generous free tier for small projects
‚úÖ **HTTPS Included** - Automatic SSL certificates

**When to use alternative deployment:**
- Need containerization (Docker/Kubernetes)
- Existing cloud infrastructure (AWS/GCP/Azure)
- On-premise requirements
- Heavy CPU/memory workloads

### Why Deno 2?

‚úÖ **Zero Configuration** - TypeScript, testing, linting, formatting built-in
‚úÖ **Secure by Default** - Explicit permissions for file, network, env access
‚úÖ **Modern Web APIs** - fetch, crypto, Web Streams natively supported
‚úÖ **Fast Package Resolution** - JSR registry, npm compatibility
‚úÖ **Built-in Deno KV** - Key-value database included
‚úÖ **Single Executable** - Compile to standalone binary (optional)
‚úÖ **Edge-Ready** - Perfect for Deno Deploy and serverless

You can still use npm packages when needed via `npm:` specifier.

## Customization

### Adding Custom Agents

Create a new file in `.claude/agents/`:

```markdown
# My Custom Agent

Your agent description and responsibilities...

## Output Format
[What this agent produces]
```

### Adding Custom Commands

Create a new file in `.claude/commands/`:

```markdown
---
description: Short description for the command
---

Your command instructions...
```

## Examples

### Example 1: Building Your First Feature (Recommended)

Starting from a fresh template:

```bash
# Step 1: Define your project
/requirements
> "I want to build a task management app where users can create,
   complete, and organize tasks into projects"

# Step 2: Design architecture
/architect
# Agent evaluates requirements and recommends:
# - Hono for REST API
# - Deno KV for data storage (tasks + projects)
# - Fresh for the UI
# - Creates docs/architecture.md and ADRs

# Step 3: Build first feature
/new-feature
> "task-creation"

# The command will guide you through:
# - Gather detailed requirements for task creation
# - Design API endpoint (POST /api/tasks)
# - Design Deno KV schema for tasks
# - Write tests following TDD
# - Implement backend logic
# - Implement frontend form
```

### Example 2: Quick Start with Defaults

Skip requirements/architecture and jump right in:

```bash
/new-feature
> "user-authentication"

# First-run detection triggers:
‚ö†Ô∏è  I noticed this might be your first feature!

Would you like to:
a) Run /requirements + /architect first (recommended)
b) Continue with default architecture (Hono + Fresh + Deno KV)
c) Skip architecture setup

# Choose (b) for quick start with sensible defaults
# The agent will use the template's default stack
```

### Example 3: Advanced Automation (Optional)

Using Level 3 (fully automated):

```bash
# After architecture is defined, use orchestrator for complex features
/auto-feature
> "Add user authentication with JWT tokens and role-based access control"

# The orchestrator will:
# - Analyze current project state
# - Create and present execution plan
# - Automatically invoke required agents
# - Validate outputs at each step
# - Report completion with test results
```

## Troubleshooting

### Tests Failing

1. Check that you're in the Green phase (tests should be written first)
2. Review test expectations vs. implementation
3. Run specific test: `deno test <file-name>`

### Agent Not Following Architecture

1. Ensure `docs/architecture.md` exists and is up-to-date
2. Remind the agent to read architecture docs
3. Update ADRs for new decisions

### API Mismatch Between Frontend/Backend

1. Check `docs/api-spec.md` is the source of truth
2. Both agents should reference this file
3. Update spec first, then regenerate code

## Contributing

This is a template repository. Customize it for your needs!

To improve the template:
1. Fork this repository
2. Make your changes
3. Submit a pull request

## License

MIT License - feel free to use for any purpose.

## Resources

- [Quick Reference](docs/QUICK_REFERENCE.md) - Condensed guide for common patterns
- [Detailed Guides](docs/guides/) - Comprehensive guides for advanced topics
- [Claude Code Documentation](https://docs.claude.com/claude-code)
- [Test-Driven Development](https://martinfowler.com/bliki/TestDrivenDevelopment.html)
- [Architecture Decision Records](https://adr.github.io/)
- [Quick Start Guide](QUICKSTART.md) - Get started in 5 minutes
- [Fresh Documentation](https://fresh.deno.dev/docs/getting-started)
- [Deno Documentation](https://deno.com/)

## Deployment to Deno Deploy

### Initial Setup (One-time)

1. **Create a Deno Deploy account**
   - Visit https://dash.deno.com
   - Sign in with GitHub

2. **Create a new project**
   - Click "New Project"
   - Choose your GitHub repository
   - Set project name (e.g., `my-app`)

3. **Configure GitHub secrets**
   - Go to your GitHub repo ‚Üí Settings ‚Üí Secrets
   - Add `DENO_DEPLOY_TOKEN` from Deno Deploy dashboard

4. **Update configuration**
   - Edit `deno.json` ‚Üí change `your-project-name` to your actual project name
   - Edit `.github/workflows/ci.yml` ‚Üí change `your-project-name`

### Deploying

**Automatic deployment** (recommended):
```bash
git push origin main
# GitHub Actions automatically deploys to Deno Deploy
```

**Manual deployment**:
```bash
# Install deployctl
deno install -A jsr:@deno/deployctl

# Deploy to production
deno task deploy

# Deploy preview
deno task deploy:preview
```

### Database on Deno Deploy

Deno KV is automatically available on Deno Deploy:
```typescript
// Works locally and on Deno Deploy - no config needed!
const kv = await Deno.openKv();
```

On Deno Deploy, Deno KV is:
- **Globally distributed** - Replicated across edge locations
- **Eventually consistent** - Optimized for low latency reads
- **Managed** - No setup or maintenance required

### Local Development with Deno KV

Deno KV uses SQLite locally and FoundationDB in production. See `docs/guides/DENO_KV_GUIDE.md` for comprehensive best practices.

**Quick Setup**:
```typescript
// backend/lib/kv.ts - Single instance pattern
let kvInstance: Deno.Kv | null = null;

export async function getKv(): Promise<Deno.Kv> {
  if (!kvInstance) {
    const env = Deno.env.get('DENO_ENV') || 'development';
    const path = env === 'production' ? undefined : './data/local.db';
    kvInstance = await Deno.openKv(path);
  }
  return kvInstance;
}
```

**Storage Locations**:
- **Local**: `./data/local.db` (SQLite file)
- **Testing**: `:memory:` (in-memory, no files)
- **Production**: FoundationDB (Deno Deploy)

**Management Commands**:
```bash
deno task kv:seed      # Add sample data
deno task kv:reset     # Clear all data
deno task kv:inspect   # View stored data
```

**Best Practices**:
- ‚úÖ Use single instance pattern (don't call `Deno.openKv()` on every request)
- ‚úÖ Use `:memory:` for tests (fast, isolated)
- ‚úÖ Add `data/*.db` to `.gitignore` (already configured)
- ‚úÖ See `docs/guides/DENO_KV_GUIDE.md` for complete guide

## Deno 2 Quick Reference

```bash
# Development
deno task dev              # Start dev server (both backend + frontend)
deno test                  # Run tests
deno task test:coverage    # Test coverage
deno lint                  # Lint code
deno fmt                   # Format code
deno task type-check       # Type checking

# Deployment (Deno Deploy - Recommended)
deno task deploy           # Deploy to production
deno task deploy:preview   # Deploy preview environment
git push origin main       # Auto-deploy via GitHub Actions

# Build (for Docker/VPS deployment)
deno task build            # Build for production
deno compile               # Create standalone executable
deno task start            # Run production build
```

## Support

For issues or questions:
- Check existing documentation in `docs/`
- Use `/review` to validate your implementation
- Consult the agent definitions in `.claude/agents/`
- [Deno Documentation](https://deno.land/manual)
- [Hono Documentation](https://hono.dev/)

---

**Happy Building! üöÄ**

**Recommended:** Start with `/new-feature` for most projects.

**Learning:** Use manual commands (`/requirements`, `/architect`, etc.) to understand the workflow.

**Advanced:** Try `/auto-feature` for complex projects requiring maximum automation.

See [Quick Reference](docs/QUICK_REFERENCE.md) for common patterns or [Orchestration Guide](docs/guides/ORCHESTRATION_GUIDE.md) for detailed automation levels.

# Backlog
* Add a hamburger menu to the menu bar
* update home screen with mockup command
* Setup integration tests to to test the api layer directly
* Add open api link to home page info
  - Swagger UI: http://localhost:8000/api/docs (interactive testing)
  - ReDoc: http://localhost:8000/api/redoc (clean reading experience)
  - OpenAPI JSON: http://localhost:8000/api/openapi.json (raw spec)
  - API Info: http://localhost:8000/ (lists all endpoints)

* Evaluate Open API implementation, is Redoc the right choice?
* Error monitoring: Optional setting to integrate with something like Datadog?
* Provide command for commits and ensure a commit format is used?




  üéØ Priority Ranking

Do Soon:
4. Add refresh token mechanism
5. Implement token revocation/blacklist
6. Add CSRF protection
7. Implement constant-time comparisons

Nice to Have:
8. Email verification
9. Password reset flow
10. Account lockout after failed attempts
11. Better logging and monitoring
12. Stronger password requirements


The dev server is running with all improvements active. You can test by:

Logging in with test@example.com / password123
Trying multiple failed login attempts to see rate limiting
The auth system is now significantly more secure!